/**
Atomix project, edmaConfig.c, TODO: insert summary here
Copyright (c) 2015 Stanford University
Released under the Apache License v2.0. See the LICENSE file for details.
Author(s): Manu Bansal
*/

#include "../../inc/vcpdriver/vcpdriver.h"
#include <osl/inc/swpform.h>
#include <stdio.h>
#include <ti/csl/csl_vcp2.h>
#include <ti/csl/csl_vcp2Aux.h>
#include <ti/csl/csl_tsc.h>
#include <ti/csl/csl_edma3.h>
#include <assert.h>
#include "../../inc/vcpdriver/edmaConfig.h"




/* EDMA global declarations */
/* Edma handle */
CSL_Edma3Handle     VCPDRV_hModule; 
CSL_Edma3Obj  VCPDRV_edmaObj;
    
CSL_Edma3Context VCPDRV_context;
CSL_Edma3ChannelObj VCPDRV_chObjTx[4], VCPDRV_chObjRx[4];
CSL_Edma3ChannelHandle VCPDRV_hChannelTx[4], VCPDRV_hChannelRx[4];
//CSL_Edma3ParamHandle hParam[4][4];  /* Example uses 4 PaRAMs */
CSL_Edma3ParamHandle VCPDRV_hParam[4][6];
#pragma DATA_ALIGN(VCPDRV_paramSetup, 8);
//CSL_Edma3ParamSetup paramSetup[4][4];
CSL_Edma3ParamSetup VCPDRV_paramSetup[4][6];
CSL_Edma3ChannelAttr VCPDRV_chParamTx[4], VCPDRV_chParamRx[4];
CSL_Edma3ChannelErr VCPDRV_chErrClear;
Uint32 VCPDRV_paramNum[4][6];

Uint32 * VCPDRV_pVcAddrWord[4];
Uint32 * VCPDRV_pBmAddrWord[4];
Uint32 * VCPDRV_pBmABCntWord[4];
Uint32 * VCPDRV_pHdAddrWord[4];
Uint32 * VCPDRV_pHdABCntWord[4];
Uint32 * VCPDRV_pHdSrcBIdxWord[4];

Uint32 VCPDRV_idTCINT[4];
Uint32 VCPDRV_intMask[4];
CSL_Edma3CmdIntr 			VCPDRV_transferCompletionInterruptMask[4];

CSL_Status refreshEdmaChannels(Uint32 vcpInstNum) {
	    /* clear the EDMA error registers */
	Uint32 vcpin = vcpInstNum;
	CSL_Status status;
//	printf("refreshing channels for vcp instance %d\n", vcpin);
	
////	printf("Edma error register status after vcp processing:\n");
////    vcp2_queryEdmaErrorRegisters(hChannelTx[vcpin], hChannelRx[vcpin]);
////    printf("----------- hChannelTx ------------\n");
////    vcp2_queryEdmaChannelStatus(hChannelTx[vcpin]);
////    printf("----------- hChannelRx ------------\n");
////    vcp2_queryEdmaChannelStatus(hChannelRx[vcpin]);	
	
	
    VCPDRV_chErrClear.missed = TRUE;
    VCPDRV_chErrClear.secEvt = TRUE;
    
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_DISABLE, NULL);
    if (CSL_SOK != status) {
    	ERROR("");
    }
//    else {
//    	SUCCESS("");
//    }
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_DISABLE, NULL);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_CLEARERR, &VCPDRV_chErrClear);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_CLEARERR, &VCPDRV_chErrClear);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_CLEAR, NULL);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_CLEAR, NULL);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }

    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }
    
    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	printf("ERROR status: %d\n", status);
    	ERROR("");
    	return status;
    }

    return CSL_SOK;
}

//the original version
void initVcpEdma() {
	Uint32 vcpi0 = 0, vcpi1 = 1, vcpi2 = 2, vcpi3 = 3;
	
	Uint32 i, j, k = 0;
	
	//transfer completion interrupt values generated by respective edma channels
	VCPDRV_idTCINT[0] = 60;	VCPDRV_intMask[0] = 0x10000000;
	VCPDRV_idTCINT[1] = 61;	VCPDRV_intMask[1] = 0x20000000;
	VCPDRV_idTCINT[2] = 62;	VCPDRV_intMask[2] = 0x40000000;
	VCPDRV_idTCINT[3] = 63;	VCPDRV_intMask[3] = 0x80000000;
	
	
	vcp2_configureEdmaOnce();
	
	initEdmaOncePerVcpAll(0, 0, 0, 0);
}

//the new version
void initVcpEdmaOnlyTopLevel() {

	
	//transfer completion interrupt values generated by respective edma channels
	VCPDRV_idTCINT[0] = 60;	VCPDRV_intMask[0] = 0x10000000;
	VCPDRV_idTCINT[1] = 61;	VCPDRV_intMask[1] = 0x20000000;
	VCPDRV_idTCINT[2] = 62;	VCPDRV_intMask[2] = 0x40000000;
	VCPDRV_idTCINT[3] = 63;	VCPDRV_intMask[3] = 0x80000000;
	
	
	vcp2_configureEdmaOnce();
}

void initEdmaOncePerVcpAll(
	VCP2_ConfigIc *pVcpConfig,
	Uint64 *outputParams,
    Uint32 inputBM,
    Uint32 outputHD
) {
	Uint32 vcpi0 = 0, vcpi1 = 1, vcpi2 = 2, vcpi3 = 3;
	
	Uint32 i, j, k = 0;
	
	for (i = 0; i < 4; i++)
//	  for (j = 0; j < 4; j++)
	  for (j = 0; j < 6; j++)
	    VCPDRV_paramNum[i][j] = 200 + k++;		//which param's you use is critical!
	    								//params could be conflicting.
#ifdef DEVICE_K2K

	vcp2_configureEdmaOncePerVcp (
		vcpi0,
		CSL_EDMACC_2_VCP_0_XEVT0, //TPCC2_VCP0XEVT,
		CSL_EDMACC_2_VCP_0_REVT0, //CSL_TPCC2_VCP0REVT,
		 
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
	    );

	vcp2_configureEdmaOncePerVcp (
		vcpi1,
		CSL_EDMACC_2_VCP_0_XEVT1, //CSL_TPCC2_VCP1XEVT,
		CSL_EDMACC_2_VCP_0_REVT1, //CSL_TPCC2_VCP1REVT,

		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);
		
	vcp2_configureEdmaOncePerVcp (
		vcpi2,
		CSL_EDMACC_2_VCP_0_XEVT2, //CSL_TPCC2_VCP2XEVT,
		CSL_EDMACC_2_VCP_0_REVT2, //CSL_TPCC2_VCP2REVT,
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);

	vcp2_configureEdmaOncePerVcp (
		vcpi3,
		CSL_EDMACC_2_VCP_0_XEVT3, //CSL_TPCC2_VCP3XEVT,
		CSL_EDMACC_2_VCP_0_REVT3, //CSL_TPCC2_VCP3REVT,
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);
#else
	vcp2_configureEdmaOncePerVcp (
		vcpi0,
		CSL_TPCC2_VCP0XEVT,
		CSL_TPCC2_VCP0REVT,
		 
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
	    );

	vcp2_configureEdmaOncePerVcp (
		vcpi1,
		CSL_TPCC2_VCP1XEVT,
		CSL_TPCC2_VCP1REVT,

		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);
		
	vcp2_configureEdmaOncePerVcp (
		vcpi2,
		CSL_TPCC2_VCP2XEVT,
		CSL_TPCC2_VCP2REVT,
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);

	vcp2_configureEdmaOncePerVcp (
		vcpi3,
		CSL_TPCC2_VCP3XEVT,
		CSL_TPCC2_VCP3REVT,
		pVcpConfig,
		outputParams,
		
		0, //branch_metric,
		0, //hard_decision,
		
	    inputBM,
	    outputHD
		);
#endif
}



/**
 * Configurator for EDMA channels required for VCP.
 */
 

/*
 * ============================================================================
 *   @func   vcp2_configEdma
 *   @desc
 *      Configures EDMA channels 28 and 29. 
 *   @n For channel 29 there are 2 param entries(0 &1) which are linked. 
 *   @n -   Link 0 transfers the VCP2 input configuration register values.
 *   @n -   Link 1 transfers Branch metrics.
 *   @n
 *   @n For channel 28 there 2 param entry (2 & 3).
 *   @n -   Link 2 transfers the Hard decisions.
 *   @n -   Link 3 transfers the VCPOUT values
 *
 *   @expected result
 *      Appropriate message will be logged depending on 
 *      the result
 *
 *   @eg
 *      vcp2_configEdma(inputBm, ouputHD);  
 * ============================================================================
 */
//#define CSL_TPCC2_VCPXEVT  CSL_TPCC2_VCP0XEVT
//#define CSL_TPCC2_VCPREVT  CSL_TPCC2_VCP0XEVT


Uint16 vcp2_configureEdmaOnce () {
	CSL_Status status;
	
//	CSL_Edma3HwDmaChannelSetup	dmahwSetup[64] =
//								CSL_EDMA3_DMACHANNELSETUP_DEFAULT;
//CSL_Edma3HwQdmaChannelSetup qdmahwSetup[CSL_EDMA3_NUM_QDMACH] =
//	CSL_Edma3HwQdmaChannelSetup qdmahwSetup[8] =
//								CSL_EDMA3_QDMACHANNELSETUP_DEFAULT;

    
//10 VCPAREVT Receive event
//11 VCPAXEVT Transmit event
    
    /* EDMA Initialization */
    status = CSL_edma3Init (&VCPDRV_context);
	if (status != CSL_SOK) { ERROR("edma3Init"); return status;}
	 
//    CSL_edma3Open (&edmaObj, CSL_EDMA3, NULL, &status);
    VCPDRV_hModule = CSL_edma3Open (&VCPDRV_edmaObj, VCPDRV_EDMA_INSTANCE_NUMBER, NULL, &status);
    //using instance 2 because it seems that's the one tied to vcp events
    if ( (VCPDRV_hModule == NULL) || (status != CSL_SOK)) { 
    	ERROR("edma3Open"); 
    	return status; 
    }
    
    DEBUG(printf("CSL_edma3Open status: %d\n", status);)

//    hwSetup.dmaChaSetup = dmahwSetup;
//    hwSetup.qdmaChaSetup = qdmahwSetup;

//    status = CSL_edma3HwSetup(hModule,&hwSetup);
//    if (status != CSL_SOK) { bailOut(); return status; }

	vcp2_setupTransferCompletionInterruptMasks();
	vcp2_enableTransferCompletionInterrupts();
}

Uint16 vcp2_configureEdmaOncePerVcp_disabled(	//THE ONE THAT WORKED INITIALLY
	Uint32 vcpin,
	Uint32 idVCPXEVT,
	Uint32 idVCPREVT, 
	VCP2_ConfigIc *pVcpConfig,
	Uint64 *outputParams,
	Uint32 *branch_metric,
	Uint32 *hard_decision,
    Uint32 inputBM,
    Uint32 outputHD
)
{
    CSL_Status status, chStatus, chStatus1;

    Uint32 receive_link_offset, transmit_link_offset;
    Uint32 receive_link_offset2, transmit_link_offset2;
//    CSL_Edma3HwSetup            hwSetup;
    
    CSL_Status stat0, stat1, stat2, stat3, stat4, stat5;
    
    Uint32 *paramPtr;
    

	
	VCP2Handle hVcpThis;
	hVcpThis = VCPDRV_hVcp[vcpin];

	ASSERT_PTR_ALIGNED(pVcpConfig, 8);
	ASSERT_PTR_ALIGNED(outputParams, 8);
	ASSERT_PTR_ALIGNED(branch_metric, 8);
	ASSERT_PTR_ALIGNED(hard_decision, 8);
	
//	printf("configureEdmaOnce^^^^^^^^^^^^^^^^^^^^\n");
	
	//**********************************
	// TX CHANNEL
	//**********************************

    /* Channel Configuration for VCPXEVT event */
    /* Channel Open */
    VCPDRV_chParamTx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
    VCPDRV_chParamTx[vcpin].chaNum = idVCPXEVT;	//0xb == 11
    
    VCPDRV_hChannelTx[vcpin] = CSL_edma3ChannelOpen (&VCPDRV_chObjTx[vcpin], VCPDRV_hModule->instNum, &VCPDRV_chParamTx[vcpin], &chStatus);
    status = chStatus;
    if ( (VCPDRV_hChannelTx[vcpin] == NULL) || (status != CSL_SOK)) { 
    	ERROR("edma3ChannelOpen Tx"); 
    	return status; 
    }
	   
//    printf("EER register memory location: 0x%08x\n", &(hModule->regs->TPCC_EER));
//    printf("EER register memory value bf: 0x%08x\n", hModule->regs->TPCC_EER);
    VCPDRV_hModule->regs->TPCC_EESR |= (Uint32)(0x1 << idVCPXEVT);
//    printf("EER register memory value af: 0x%08x\n", hModule->regs->TPCC_EER);
    
    if ((chStatus != CSL_SOK) || (VCPDRV_hChannelTx[vcpin] == NULL)) {
        printf ("Error in EDMA channel open function\n");
        return 0;
    }

    /* Channel Setup */
    if (CSL_SOK != CSL_edma3HwChannelSetupParam (VCPDRV_hChannelTx[vcpin],
//            0 /* PaRAM entry */ )) {
			VCPDRV_paramNum[vcpin][0])) {
        printf ("Error in Tx EDMA channel setup\n");
        return 0;
    }
    if (CSL_SOK != CSL_edma3HwChannelSetupQue (VCPDRV_hChannelTx[vcpin],
       CSL_EDMA3_QUE_0)) {
        printf ("Error in Tx EDMA channel setup\n");
        return 0;
    }

	
	//**********************************
	// RX CHANNEL
	//**********************************


    /* Channel Configuration for VCPREVT event */
    /* Channel Open */
    VCPDRV_chParamRx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
    VCPDRV_chParamRx[vcpin].chaNum = idVCPREVT;
    
    VCPDRV_hChannelRx[vcpin] =
//        CSL_edma3ChannelOpen (&chObjRx, CSL_EDMA3, &chParamRx, &chStatus1);
        CSL_edma3ChannelOpen (&VCPDRV_chObjRx[vcpin], VCPDRV_hModule->instNum, &VCPDRV_chParamRx[vcpin], &chStatus1);
    status = chStatus1;
    if ( (VCPDRV_hChannelRx[vcpin] == NULL) || (status != CSL_SOK)) { 
    	ERROR("edma3ChannelOpen Rx"); 
    	return status; 
    }
    
    
//    printf("EER register memory location: 0x%08x\n", &(hModule->regs->TPCC_EER));
//    printf("EER register memory value bf: 0x%08x\n", hModule->regs->TPCC_EER);        
    VCPDRV_hModule->regs->TPCC_EESR |= (Uint32)(0x1 << idVCPREVT);
//	printf("EER register memory value af: 0x%08x\n", hModule->regs->TPCC_EER);
    
    if ((chStatus1 != CSL_SOK) | (VCPDRV_hChannelRx[vcpin] == NULL)) {
        printf ("Error in EDMA channel open function\n");
        return 0;
    }

    /* Channel Setup */
    if (CSL_SOK != CSL_edma3HwChannelSetupParam (VCPDRV_hChannelRx[vcpin],
//            2 /* PaRAM entry */ )) {
			VCPDRV_paramNum[vcpin][2])) {
        printf ("Error in Rx EDMA channel setup\n");
        return 0;
    }
    if (CSL_SOK != CSL_edma3HwChannelSetupQue (VCPDRV_hChannelRx[vcpin],
        CSL_EDMA3_QUE_0)) {
        printf ("Error in Rx EDMA channel setup\n");
        return 0;
    }
	
	//**********************************
	// PaRAM configurations
	//**********************************
	
	
    /* Using PaRAMs 0, 1, 2, 3 */
    /* 0 and 1 are to transmit */
    /* 2 and 3 are to receive */
//    hParam[0] = CSL_edma3GetParamHandle (hChannelTx[vcpin], 0, &stat1);
//    hParam[1] = CSL_edma3GetParamHandle (hChannelTx[vcpin], 1, &stat2);
//    hParam[2] = CSL_edma3GetParamHandle (hChannelRx[vcpin], 2, &stat3);
//    hParam[3] = CSL_edma3GetParamHandle (hChannelRx[vcpin], 3, &stat4);
    VCPDRV_hParam[vcpin][0] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][0], &stat0);
    VCPDRV_hParam[vcpin][1] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][1], &stat1);
    VCPDRV_hParam[vcpin][2] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][2], &stat2);
    VCPDRV_hParam[vcpin][3] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][3], &stat3);

	//auxiliary for duplicating base params
    VCPDRV_hParam[vcpin][4] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][4], &stat4);
    VCPDRV_hParam[vcpin][5] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][5], &stat5);
    
//	pBmAddrWord[vcpin] = &(((Uint32 *)(hParam[vcpin][1]))[1]);	//src address word
//	pHdAddrWord[vcpin] = &(((Uint32 *)(hParam[vcpin][2]))[3]);	//dst address word

//typedef struct  {
//    volatile Uint32 OPT;
//    volatile Uint32 SRC;
//    volatile Uint32 A_B_CNT;
//    volatile Uint32 DST;
//    volatile Uint32 SRC_DST_BIDX;
//    volatile Uint32 LINK_BCNTRLD;
//    volatile Uint32 SRC_DST_CIDX;
//    volatile Uint32 CCNT;
//} CSL_TPCC_ParamsetRegs;

//typedef volatile CSL_TPCC_ParamsetRegs *CSL_Edma3ParamHandle;
	
	paramPtr = (Uint32 *)(VCPDRV_hParam[vcpin][1]);
	VCPDRV_pBmAddrWord[vcpin] = &paramPtr[1];
	VCPDRV_pBmABCntWord[vcpin] = &paramPtr[2];

	paramPtr = (Uint32 *)(VCPDRV_hParam[vcpin][2]);
	VCPDRV_pHdAddrWord[vcpin] = &paramPtr[3];
	VCPDRV_pHdABCntWord[vcpin] = &paramPtr[2];
	VCPDRV_pHdSrcBIdxWord[vcpin] = &paramPtr[4];


//    hParam[0] = CSL_edma3GetParamHandle (hChannelTx, 500, &stat1);
//    hParam[1] = CSL_edma3GetParamHandle (hChannelTx, 501, &stat2);
//    hParam[2] = CSL_edma3GetParamHandle (hChannelRx, 502, &stat3);
//    hParam[3] = CSL_edma3GetParamHandle (hChannelRx, 503, &stat4);



    
    DEBUG(
//      printf("statuses of GetParamHandle: %d, %d, %d, %d, %d, %d\n", stat0, stat1, stat2, stat3, stat4, stat5);
    )

    /* Lower 4 nibbles of the PaRAM address forms the link offset */

    /* PaRAMs 0 and 1 are linked, and also 4 */
    transmit_link_offset = (Uint32)VCPDRV_hParam[vcpin][1] & 0x0000FFFF; 
    transmit_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][4] & 0x0000FFFF;

    /* PaRAMs 2 and 3 are linked, and also 5*/
    receive_link_offset = (Uint32)VCPDRV_hParam[vcpin][3] & 0x0000FFFF;
    receive_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][5] & 0x0000FFFF;

	//**********************************
	// TX PaRAM configurations
	//**********************************



    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    SAM, DAM are to increment, so fwid = none
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination address increment
     *  sam       -    Source address increment
     */
    VCPDRV_paramSetup[vcpin][0].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_NONE, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_INCR);                               /* Options */
    VCPDRV_paramSetup[vcpin][0].srcAddr = (Uint32) pVcpConfig;         /* Source address */
    VCPDRV_paramSetup[vcpin][0].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_VCPIC_DMA_SIZE, 1);
                                /* Single transfer of VCPIC_DMA_SIZE bytes */
                                
//    VCPDRV_paramSetup[vcpin][0].dstAddr = (Uint32) &hVcp2Vbus->VCPIC0;      /* Destination address */
    VCPDRV_paramSetup[vcpin][0].dstAddr = (Uint32) &hVcpThis->regs->VCPIC0;      /* Destination address */
    
    VCPDRV_paramSetup[vcpin][0].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][0].linkBcntrld =
         CSL_EDMA3_LINKBCNTRLD_MAKE (transmit_link_offset, 0);  /* linking */
    VCPDRV_paramSetup[vcpin][0].srcDstCidx = CSL_EDMA3_CIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][0].cCnt = 1;                                  /* CCount is 1 */
    status = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][0], &VCPDRV_paramSetup[vcpin][0]);
    if (CSL_SOK != status) {
        printf ("Error in EDMA paRam setup for VCP IC register transfer: %d\n", status);
        return 0;
    }

//	printf("copyping sizeof(CSL_Edma3ParamSetup) bytes: %d\n", sizeof(CSL_Edma3ParamSetup));
	memcpy(&VCPDRV_paramSetup[vcpin][4], &VCPDRV_paramSetup[vcpin][0], sizeof(CSL_Edma3ParamSetup));

    transmit_link_offset = (Uint32)VCPDRV_hParam[vcpin][2] & 0x0000FFFF; 

    /* Setup link to transmit branch metrics */
    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    64-bit
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination is a FIFO
     *  sam       -    Source address increment
     */
    VCPDRV_paramSetup[vcpin][1].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_64BIT, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_CONST,
        CSL_EDMA3_ADDRMODE_INCR);                                /* Options */
    VCPDRV_paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
                                                /* Source address increment */

    VCPDRV_paramSetup[vcpin][1].dstAddr = (Uint32) & (hVcpThis->regs->VCPWBM);
                                                     /* Destination address */
    VCPDRV_paramSetup[vcpin][1].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
    VCPDRV_paramSetup[vcpin][1].srcDstBidx = CSL_EDMA3_BIDX_MAKE (VCPDRV_DMA_BURST_SIZE, 0);
    VCPDRV_paramSetup[vcpin][1].linkBcntrld =
//        CSL_EDMA3_LINKBCNTRLD_MAKE (CSL_EDMA3_LINK_NULL, 0);	/* No linking */
        CSL_EDMA3_LINKBCNTRLD_MAKE (transmit_link_offset2, 0);
                                                              

                               /* inputBM transfers of DMA_BURST_SIZE bytes */
    VCPDRV_paramSetup[vcpin][1].cCnt = 1;                                   /* CCount is 1 */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][1], &VCPDRV_paramSetup[vcpin][1])) {
        printf ("Error in EDMA paRam setup for branch metrics transfer\n");
        return 0;
    }

    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][4], &VCPDRV_paramSetup[vcpin][4])) {
        printf ("Error in EDMA paRam setup for copy param\n");
        return 0;
    }


	//**********************************
	// RX PaRAM configurations
	//**********************************

    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    64-bit
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination to increment
     *  sam       -    Source is a FIFO
     */

    VCPDRV_paramSetup[vcpin][2].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_64BIT, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_CONST);                               /* Options */
    VCPDRV_paramSetup[vcpin][2].srcAddr = (Uint32)&(hVcpThis->regs->VCPRDECS);      /* Source */
    VCPDRV_paramSetup[vcpin][2].aCntbCnt = CSL_EDMA3_CNT_MAKE (outputHD, 1);
                                           /* outputHD bytes in a transfer */
    VCPDRV_paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
    VCPDRV_paramSetup[vcpin][2].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, outputHD);
                                                      
    VCPDRV_paramSetup[vcpin][2].linkBcntrld =
         CSL_EDMA3_LINKBCNTRLD_MAKE (receive_link_offset, 0);  /* linking */

    VCPDRV_paramSetup[vcpin][2].srcDstCidx = CSL_EDMA3_CIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][2].cCnt = 1;                                       /* CCount */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][2], &VCPDRV_paramSetup[vcpin][2])) {
        printf ("Error in EDMA paRam setup for decisions read\n");
        return 0;
    }

//	printf("copying again\n");
	memcpy(&VCPDRV_paramSetup[vcpin][5], &VCPDRV_paramSetup[vcpin][2], sizeof(CSL_Edma3ParamSetup));

    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    SAM, DAM are to increment, so fwid = none
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination address increment
     *  sam       -    Source address increment
     */

//    VCPDRV_paramSetup[vcpin][3].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
    VCPDRV_paramSetup[vcpin][3].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, CSL_EDMA3_TCINT_EN, VCPDRV_idTCINT[vcpin],
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_NONE, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_INCR);                                 /* Options */
    VCPDRV_paramSetup[vcpin][3].srcAddr = (Uint32) & (hVcpThis->regs->VCPOUT1);       /* Source */
    VCPDRV_paramSetup[vcpin][3].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_VCPOUT_DMA_SIZE, 1);
                                 /* Transfer of VCPOUT_DMA_SIZE bytes 1 time */
//    VCPDRV_paramSetup[vcpin][3].dstAddr = (Uint32) & ouputParams[0];         /* Destination */
    VCPDRV_paramSetup[vcpin][3].dstAddr = (Uint32) outputParams;         /* Destination */
    VCPDRV_paramSetup[vcpin][3].linkBcntrld =
//        CSL_EDMA3_LINKBCNTRLD_MAKE (CSL_EDMA3_LINK_NULL, 0);	  /* No linking */
        CSL_EDMA3_LINKBCNTRLD_MAKE (receive_link_offset2, 0);	  /* No linking */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][3], &VCPDRV_paramSetup[vcpin][3])) {
        printf ("Error in EDMA paRam setup for output registers read\n");
        return 0;
    }

    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][5], &VCPDRV_paramSetup[vcpin][5])) {
        printf ("Error in EDMA paRam setup for copy param\n");
        return 0;
    }

    
    
    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	ERROR("");
    }
    
    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	ERROR("");
    }
//    refreshEdmaChannels(vcpin);
    
	return 1;
}


//This version sets up param linking so that params are a cyclic fifo:
//VCPIC PaRAM initial (in native param) [0] --> Branch Metrics PaRAM [1] --> VCPIC PaRAM copy [4]
//Hard Decisions (intial in native) [2] --> OutRegs [3] --> Hard Decisions (copy) [5]
Uint16 vcp2_configureEdmaOncePerVcp (			//TRY 3
	Uint32 vcpin,
	Uint32 idVCPXEVT,
	Uint32 idVCPREVT, 
	VCP2_ConfigIc *pVcpConfig,
	Uint64 *outputParams,
	Uint32 *branch_metric,
	Uint32 *hard_decision,
    Uint32 inputBM,
    Uint32 outputHD
)
{
    CSL_Status status, chStatus, chStatus1;

    Uint32 receive_link_offset, transmit_link_offset;
    Uint32 receive_link_offset2, transmit_link_offset2;
    
    CSL_Status stat0, stat1, stat2, stat3, stat4, stat5;
    
    Uint32 *paramPtr;
    CSL_Edma3ParamHandle  paramHdl;
    

	
    VCP2Handle hVcpThis;
    hVcpThis = VCPDRV_hVcp[vcpin];

    ASSERT_PTR_ALIGNED(pVcpConfig, 8);
    ASSERT_PTR_ALIGNED(outputParams, 8);
    ASSERT_PTR_ALIGNED(branch_metric, 8);
    ASSERT_PTR_ALIGNED(hard_decision, 8);
    
    
    //**********************************
    // TX CHANNEL
    //**********************************

    /* Channel Configuration for VCPXEVT event */
    /* Channel Open */
    VCPDRV_chParamTx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
    VCPDRV_chParamTx[vcpin].chaNum = idVCPXEVT;	//0xb == 11
    
    VCPDRV_hChannelTx[vcpin] = CSL_edma3ChannelOpen (&VCPDRV_chObjTx[vcpin], VCPDRV_hModule->instNum, &VCPDRV_chParamTx[vcpin], &chStatus);
    status = chStatus;
    if ( (VCPDRV_hChannelTx[vcpin] == NULL) || (status != CSL_SOK)) { 
    	ERROR("edma3ChannelOpen Tx"); 
    	return status; 
    }
	   
    VCPDRV_hModule->regs->TPCC_EESR |= (Uint32)(0x1 << idVCPXEVT);
    
    if ((chStatus != CSL_SOK) || (VCPDRV_hChannelTx[vcpin] == NULL)) {
        printf ("Error in EDMA channel open function\n");
        return 0;
    }

    /* Channel Setup */
    if (CSL_SOK != CSL_edma3HwChannelSetupParam (VCPDRV_hChannelTx[vcpin],
//            0 /* PaRAM entry */ )) {
			VCPDRV_paramNum[vcpin][0])) {
        printf ("Error in Tx EDMA channel setup\n");
        return 0;
    }
    if (CSL_SOK != CSL_edma3HwChannelSetupQue (VCPDRV_hChannelTx[vcpin],
       CSL_EDMA3_QUE_0)) {
        printf ("Error in Tx EDMA channel setup\n");
        return 0;
    }

	
    //**********************************
    // RX CHANNEL
    //**********************************


    /* Channel Configuration for VCPREVT event */
    /* Channel Open */
    VCPDRV_chParamRx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
    VCPDRV_chParamRx[vcpin].chaNum = idVCPREVT;
    
    VCPDRV_hChannelRx[vcpin] =
        CSL_edma3ChannelOpen (&VCPDRV_chObjRx[vcpin], VCPDRV_hModule->instNum, &VCPDRV_chParamRx[vcpin], &chStatus1);
    status = chStatus1;
    if ( (VCPDRV_hChannelRx[vcpin] == NULL) || (status != CSL_SOK)) { 
    	ERROR("edma3ChannelOpen Rx"); 
    	return status; 
    }
    
    
    VCPDRV_hModule->regs->TPCC_EESR |= (Uint32)(0x1 << idVCPREVT);
    
    if ((chStatus1 != CSL_SOK) | (VCPDRV_hChannelRx[vcpin] == NULL)) {
        printf ("Error in EDMA channel open function\n");
        return 0;
    }

    /* Channel Setup */
    if (CSL_SOK != CSL_edma3HwChannelSetupParam (VCPDRV_hChannelRx[vcpin],
			VCPDRV_paramNum[vcpin][2])) {
        printf ("Error in Rx EDMA channel setup\n");
        return 0;
    }
    if (CSL_SOK != CSL_edma3HwChannelSetupQue (VCPDRV_hChannelRx[vcpin],
        CSL_EDMA3_QUE_0)) {
        printf ("Error in Rx EDMA channel setup\n");
        return 0;
    }
	
    //**********************************
    // PaRAM configurations
    //**********************************
	
	
    /* Using PaRAMs 0, 1, 2, 3 */
    /* 0 and 1 are to transmit */
    /* 2 and 3 are to receive */
    VCPDRV_hParam[vcpin][0] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][0], &stat0);
    VCPDRV_hParam[vcpin][1] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][1], &stat1);
    VCPDRV_hParam[vcpin][2] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][2], &stat2);
    VCPDRV_hParam[vcpin][3] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][3], &stat3);

	//auxiliary for duplicating base params
    VCPDRV_hParam[vcpin][4] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][4], &stat4);
    VCPDRV_hParam[vcpin][5] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][5], &stat5);




//typedef struct  {
//    volatile Uint32 OPT;
//    volatile Uint32 SRC;
//    volatile Uint32 A_B_CNT;
//    volatile Uint32 DST;
//    volatile Uint32 SRC_DST_BIDX;
//    volatile Uint32 LINK_BCNTRLD;
//    volatile Uint32 SRC_DST_CIDX;
//    volatile Uint32 CCNT;
//} CSL_TPCC_ParamsetRegs;
    

    //paramPtr = (Uint32 *)(VCPDRV_hParam[vcpin][0]);
    paramHdl = (VCPDRV_hParam[vcpin][0]);
    VCPDRV_pVcAddrWord[vcpin] = &(paramHdl->SRC);
	
    //paramPtr = (Uint32 *)(VCPDRV_hParam[vcpin][1]);
    paramHdl = (VCPDRV_hParam[vcpin][1]);
    //VCPDRV_pBmAddrWord[vcpin] = &paramPtr[1];
    //VCPDRV_pBmABCntWord[vcpin] = &paramPtr[2];
    VCPDRV_pBmAddrWord[vcpin] = &(paramHdl->SRC);
    VCPDRV_pBmABCntWord[vcpin] = &(paramHdl->A_B_CNT);

    //paramPtr = (Uint32 *)(VCPDRV_hParam[vcpin][2]);
    paramHdl = (VCPDRV_hParam[vcpin][2]);
    //VCPDRV_pHdAddrWord[vcpin] = &paramPtr[3];
    //VCPDRV_pHdABCntWord[vcpin] = &paramPtr[2];
    //VCPDRV_pHdSrcBIdxWord[vcpin] = &paramPtr[4];
    VCPDRV_pHdAddrWord[vcpin] = &(paramHdl->DST);
    VCPDRV_pHdABCntWord[vcpin] = &(paramHdl->A_B_CNT);
    VCPDRV_pHdSrcBIdxWord[vcpin] = &(paramHdl->SRC_DST_BIDX);


    /* Lower 4 nibbles of the PaRAM address forms the link offset */

    /* PaRAMs 0 and 1 are linked, and also 4 */
    transmit_link_offset = (Uint32)VCPDRV_hParam[vcpin][1] & 0x0000FFFF; 
    transmit_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][4] & 0x0000FFFF;
    //transmit_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][0] & 0x0000FFFF;

    /* PaRAMs 2 and 3 are linked, and also 5*/
    receive_link_offset = (Uint32)VCPDRV_hParam[vcpin][3] & 0x0000FFFF;
    receive_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][5] & 0x0000FFFF;
    //receive_link_offset2 = (Uint32)VCPDRV_hParam[vcpin][2] & 0x0000FFFF;

    //**********************************
    // TX PaRAM configurations
    //**********************************


    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    SAM, DAM are to increment, so fwid = none
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination address increment
     *  sam       -    Source address increment
     */
    VCPDRV_paramSetup[vcpin][0].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_NONE, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_INCR);                               /* Options */
    VCPDRV_paramSetup[vcpin][0].srcAddr = (Uint32) pVcpConfig;         /* Source address */
    VCPDRV_paramSetup[vcpin][0].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_VCPIC_DMA_SIZE, 1);
                                /* Single transfer of VCPIC_DMA_SIZE bytes */
                                
    VCPDRV_paramSetup[vcpin][0].dstAddr = (Uint32) &hVcpThis->regs->VCPIC0;      /* Destination address */
    
    VCPDRV_paramSetup[vcpin][0].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][0].linkBcntrld =
         CSL_EDMA3_LINKBCNTRLD_MAKE (transmit_link_offset, 0);  /* linking */
    VCPDRV_paramSetup[vcpin][0].srcDstCidx = CSL_EDMA3_CIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][0].cCnt = 1;                                  /* CCount is 1 */
    status = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][0], &VCPDRV_paramSetup[vcpin][0]);
    if (CSL_SOK != status) {
        printf ("Error in EDMA paRam setup for VCP IC register transfer: %d\n", status);
        return 0;
    }

//	printf("copyping sizeof(CSL_Edma3ParamSetup) bytes: %d\n", sizeof(CSL_Edma3ParamSetup));
	memcpy(&VCPDRV_paramSetup[vcpin][4], &VCPDRV_paramSetup[vcpin][0], sizeof(CSL_Edma3ParamSetup));

    transmit_link_offset = (Uint32)VCPDRV_hParam[vcpin][2] & 0x0000FFFF; 

    /* Setup link to transmit branch metrics */
    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    64-bit
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination is a FIFO
     *  sam       -    Source address increment
     */
    VCPDRV_paramSetup[vcpin][1].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_64BIT, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_CONST,
        CSL_EDMA3_ADDRMODE_INCR);                                /* Options */
    VCPDRV_paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
                                                /* Source address increment */

    VCPDRV_paramSetup[vcpin][1].dstAddr = (Uint32) & (hVcpThis->regs->VCPWBM);
                                                     /* Destination address */
    VCPDRV_paramSetup[vcpin][1].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
    VCPDRV_paramSetup[vcpin][1].srcDstBidx = CSL_EDMA3_BIDX_MAKE (VCPDRV_DMA_BURST_SIZE, 0);
    VCPDRV_paramSetup[vcpin][1].linkBcntrld =
//        CSL_EDMA3_LINKBCNTRLD_MAKE (CSL_EDMA3_LINK_NULL, 0);	/* No linking */
        CSL_EDMA3_LINKBCNTRLD_MAKE (transmit_link_offset2, 0);
                                                              

                               /* inputBM transfers of DMA_BURST_SIZE bytes */
    VCPDRV_paramSetup[vcpin][1].cCnt = 1;                                   /* CCount is 1 */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][1], &VCPDRV_paramSetup[vcpin][1])) {
        printf ("Error in EDMA paRam setup for branch metrics transfer\n");
        return 0;
    }

    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][4], &VCPDRV_paramSetup[vcpin][4])) {
        printf ("Error in EDMA paRam setup for copy param\n");
        return 0;
    }


    //**********************************
    // RX PaRAM configurations
    //**********************************

    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    64-bit
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination to increment
     *  sam       -    Source is a FIFO
     */

    VCPDRV_paramSetup[vcpin][2].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, FALSE, 0,
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_64BIT, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_CONST);                               /* Options */
    VCPDRV_paramSetup[vcpin][2].srcAddr = (Uint32)&(hVcpThis->regs->VCPRDECS);      /* Source */
    VCPDRV_paramSetup[vcpin][2].aCntbCnt = CSL_EDMA3_CNT_MAKE (outputHD, 1);
                                           /* outputHD bytes in a transfer */
    VCPDRV_paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
    VCPDRV_paramSetup[vcpin][2].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, outputHD);
                                                      
    VCPDRV_paramSetup[vcpin][2].linkBcntrld =
         CSL_EDMA3_LINKBCNTRLD_MAKE (receive_link_offset, 0);  /* linking */

    VCPDRV_paramSetup[vcpin][2].srcDstCidx = CSL_EDMA3_CIDX_MAKE (0, 0);
                                                      /* Index do not care */
    VCPDRV_paramSetup[vcpin][2].cCnt = 1;                                       /* CCount */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][2], &VCPDRV_paramSetup[vcpin][2])) {
        printf ("Error in EDMA paRam setup for decisions read\n");
        return 0;
    }

    memcpy(&VCPDRV_paramSetup[vcpin][5], &VCPDRV_paramSetup[vcpin][2], sizeof(CSL_Edma3ParamSetup));

    /*
     *  itcchEn   -    False
     *  tcchEn    -    False
     *  itcintEn  -    False
     *  tcintEn   -    False
     *  tcc       -    0
     *  tccMode   -    Normal completion (interrupt after transfer completion)
     *  fwid      -    SAM, DAM are to increment, so fwid = none
     *  stat      -    0, linking allowed
     *  syncDim   -    A - synchronization
     *  dam       -    Destination address increment
     *  sam       -    Source address increment
     */

    VCPDRV_paramSetup[vcpin][3].option = CSL_EDMA3_OPT_MAKE (FALSE, FALSE, FALSE, CSL_EDMA3_TCINT_EN, VCPDRV_idTCINT[vcpin],
        CSL_EDMA3_TCC_NORMAL, CSL_EDMA3_FIFOWIDTH_NONE, FALSE,
        CSL_EDMA3_SYNC_A, CSL_EDMA3_ADDRMODE_INCR,
        CSL_EDMA3_ADDRMODE_INCR);                                 /* Options */
    VCPDRV_paramSetup[vcpin][3].srcAddr = (Uint32) & (hVcpThis->regs->VCPOUT1);       /* Source */
    VCPDRV_paramSetup[vcpin][3].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_VCPOUT_DMA_SIZE, 1);
                                 /* Transfer of VCPOUT_DMA_SIZE bytes 1 time */
    VCPDRV_paramSetup[vcpin][3].dstAddr = (Uint32) outputParams;         /* Destination */
    VCPDRV_paramSetup[vcpin][3].linkBcntrld =
//        CSL_EDMA3_LINKBCNTRLD_MAKE (CSL_EDMA3_LINK_NULL, 0);	  /* No linking */
        CSL_EDMA3_LINKBCNTRLD_MAKE (receive_link_offset2, 0);	  /* No linking */
    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][3], &VCPDRV_paramSetup[vcpin][3])) {
        printf ("Error in EDMA paRam setup for output registers read\n");
        return 0;
    }

    if (CSL_SOK != CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][5], &VCPDRV_paramSetup[vcpin][5])) {
        printf ("Error in EDMA paRam setup for copy param\n");
        return 0;
    }

    
    
    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelRx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	ERROR("");
    }
    
    /* Enable Channel */
    status = CSL_edma3HwChannelControl (VCPDRV_hChannelTx[vcpin], CSL_EDMA3_CMD_CHANNEL_ENABLE, NULL);
    if (CSL_SOK != status) {
    	ERROR("");
    }
    
    return 1;
}





CSL_Status vcp2_configureEdmaAgain(
		Uint32 vcpin, 
		VCP2_ConfigIc *pVcpConfig,
		Uint32 *branch_metric, 
		Uint32 *hard_decision, 
		Uint32 inputBM, 
		Uint32 outputHD) {
	
	CSL_Status stat, stat0, stat1, stat2, stat3;

	VCP2Handle hVcpThis;
	hVcpThis = VCPDRV_hVcp[vcpin];
	
	ASSERT_PTR_ALIGNED(pVcpConfig, 8);
//	ASSERT_PTR_ALIGNED(outputParams, 8);
	ASSERT_PTR_ALIGNED(branch_metric, 8);
	ASSERT_PTR_ALIGNED(hard_decision, 8);	
	
////	printf("vcp config values while setting up edma again\n");
////	printVcpConfig(pVcpConfig);
	
	VCPDRV_paramSetup[vcpin][0].srcAddr = (Uint32) pVcpConfig;
				
				
				
    VCPDRV_paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
                                                /* Source address increment */

    VCPDRV_paramSetup[vcpin][1].dstAddr = (Uint32) & (hVcpThis->regs->VCPWBM);
                                                     /* Destination address */
    VCPDRV_paramSetup[vcpin][1].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
    
    
    
    
    VCPDRV_paramSetup[vcpin][2].aCntbCnt = CSL_EDMA3_CNT_MAKE (outputHD, 1);
                                           /* outputHD bytes in a transfer */
    VCPDRV_paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
    VCPDRV_paramSetup[vcpin][2].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, outputHD);
    

    /*********************/
    ////////////////stat = refreshEdmaChannels(vcpin);
    ////////////////if (stat != CSL_SOK) {
    ////////////////	printf("EDMA Config: could not refresh edma channels successully. vcpin=%d, error code=%d\n", vcpin, stat);
    ////////////////}
    /*********************/

//    Uint32 idVCPXEVT = CSL_TPCC2_VCP0XEVT + vcpin;
//    Uint32 idVCPREVT = CSL_TPCC2_VCP0REVT + vcpin;
//
//    /* Channel Configuration for VCPXEVT event */
//    /* Channel Open */
//    chParamTx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
//    chParamTx[vcpin].chaNum = idVCPXEVT;	//0xb == 11
//
//    /* Channel Configuration for VCPREVT event */
//    /* Channel Open */
//    chParamRx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
//    chParamRx[vcpin].chaNum = idVCPREVT;
//
//    hChannelTx[vcpin] = CSL_edma3ChannelOpen (&chObjTx[vcpin], hModule->instNum, &chParamTx[vcpin], &stat);
//    if ( (hChannelTx[vcpin] == NULL) || (stat != CSL_SOK)) {
//    	ERROR("edma3ChannelOpen Tx");
//    	return stat;
//    }
//
//
//    hChannelRx[vcpin] =
////        CSL_edma3ChannelOpen (&chObjRx, CSL_EDMA3, &chParamRx, &chStatus1);
//        CSL_edma3ChannelOpen (&chObjRx[vcpin], hModule->instNum, &chParamRx[vcpin], &stat);
//    if ( (hChannelRx[vcpin] == NULL) || (stat != CSL_SOK)) {
//    	ERROR("edma3ChannelOpen Rx");
//    	return stat;
//    }
//
//
//    /***********************************/
//
//    /* Channel Setup */
//    if (CSL_SOK != CSL_edma3HwChannelSetupParam (hChannelTx[vcpin],
////            0 /* PaRAM entry */ )) {
//			paramNum[vcpin][0])) {
//        printf ("Error in Tx EDMA channel setup\n");
//        return 0;
//    }
//
//
//    /* Channel Setup */
//    if (CSL_SOK != CSL_edma3HwChannelSetupParam (hChannelRx[vcpin],
////            2 /* PaRAM entry */ )) {
//			paramNum[vcpin][2])) {
//        printf ("Error in Rx EDMA channel setup\n");
//        return 0;
//    }
//

    /***********************************/


    VCPDRV_hParam[vcpin][0] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][0], &stat0);
    VCPDRV_hParam[vcpin][1] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][1], &stat1);
    VCPDRV_hParam[vcpin][2] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][2], &stat2);
    VCPDRV_hParam[vcpin][3] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][3], &stat3);

    /***********************************/


    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][0], &VCPDRV_paramSetup[vcpin][0]);
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 0\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 0\n");
        return 0;
    }

    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][1], &VCPDRV_paramSetup[vcpin][1]);
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 1\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 1\n");
        return 0;
    }

    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][2], &VCPDRV_paramSetup[vcpin][2]);
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 2\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 2\n");
        return 0;
    }

    
    return CSL_SOK;
}


//moving to header file for inlining
//CSL_Status vcp2_configureEdmaAgain_optimized_try2(
//		Uint32 vcpin, 
//		VCP2_ConfigIc *pVcpConfig,
//		Uint32 *branch_metric, 
//		Uint32 *hard_decision,
//		Uint32 inputBM, 
//		Uint32 outputHD
//		) {
//	
//    ASSERT_PTR_ALIGNED(pVcpConfig, 8);
//    
//    *(VCPDRV_pVcAddrWord[vcpin]) = (Uint32) pVcpConfig;
//    
//    *(VCPDRV_pBmAddrWord[vcpin]) = (Uint32) branch_metric;
//
//    *(VCPDRV_pBmABCntWord[vcpin]) = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
//
//
//
//    *(VCPDRV_pHdABCntWord[vcpin]) = CSL_EDMA3_CNT_MAKE (outputHD, 1);
//
//    *(VCPDRV_pHdAddrWord[vcpin]) = (Uint32) hard_decision;
//
//    *(VCPDRV_pHdSrcBIdxWord[vcpin]) = CSL_EDMA3_BIDX_MAKE (0, outputHD);
//	
//    
//    return CSL_SOK;
//}


//this one works as a direct replacement of vcp2_configureEdmaAgain (...)
CSL_Status vcp2_configureEdmaAgain_optimized_try2_disabled(
		Uint32 vcpin, 
		VCP2_ConfigIc *pVcpConfig,
		Uint32 *branch_metric, 
		Uint32 *hard_decision, 
		Uint32 inputBM, 
		Uint32 outputHD) {
	
	CSL_Status stat, stat0, stat1, stat2, stat3;

	//VCP2Handle hVcpThis;
	//hVcpThis = VCPDRV_hVcp[vcpin];
	
	ASSERT_PTR_ALIGNED(pVcpConfig, 8);
//	ASSERT_PTR_ALIGNED(outputParams, 8);
	ASSERT_PTR_ALIGNED(branch_metric, 8);
	ASSERT_PTR_ALIGNED(hard_decision, 8);	
	
////	printf("vcp config values while setting up edma again\n");
////	printVcpConfig(pVcpConfig);
	
	VCPDRV_paramSetup[vcpin][0].srcAddr = (Uint32) pVcpConfig;
				
				
				
    VCPDRV_paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
                                                /* Source address increment */

    //VCPDRV_paramSetup[vcpin][1].dstAddr = (Uint32) & (hVcpThis->regs->VCPWBM);
                                                     /* Destination address */
    VCPDRV_paramSetup[vcpin][1].aCntbCnt = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
    
    
    
    
    VCPDRV_paramSetup[vcpin][2].aCntbCnt = CSL_EDMA3_CNT_MAKE (outputHD, 1);
                                           /* outputHD bytes in a transfer */
    VCPDRV_paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
    VCPDRV_paramSetup[vcpin][2].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, outputHD);
    

    /*********************/
    ////////////////stat = refreshEdmaChannels(vcpin);
    ////////////////if (stat != CSL_SOK) {
    ////////////////	printf("EDMA Config: could not refresh edma channels successully. vcpin=%d, error code=%d\n", vcpin, stat);
    ////////////////}
    /*********************/

//    Uint32 idVCPXEVT = CSL_TPCC2_VCP0XEVT + vcpin;
//    Uint32 idVCPREVT = CSL_TPCC2_VCP0REVT + vcpin;
//
//    /* Channel Configuration for VCPXEVT event */
//    /* Channel Open */
//    chParamTx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
//    chParamTx[vcpin].chaNum = idVCPXEVT;	//0xb == 11
//
//    /* Channel Configuration for VCPREVT event */
//    /* Channel Open */
//    chParamRx[vcpin].regionNum = CSL_EDMA3_REGION_GLOBAL;
//    chParamRx[vcpin].chaNum = idVCPREVT;
//
//    hChannelTx[vcpin] = CSL_edma3ChannelOpen (&chObjTx[vcpin], hModule->instNum, &chParamTx[vcpin], &stat);
//    if ( (hChannelTx[vcpin] == NULL) || (stat != CSL_SOK)) {
//    	ERROR("edma3ChannelOpen Tx");
//    	return stat;
//    }
//
//
//    hChannelRx[vcpin] =
////        CSL_edma3ChannelOpen (&chObjRx, CSL_EDMA3, &chParamRx, &chStatus1);
//        CSL_edma3ChannelOpen (&chObjRx[vcpin], hModule->instNum, &chParamRx[vcpin], &stat);
//    if ( (hChannelRx[vcpin] == NULL) || (stat != CSL_SOK)) {
//    	ERROR("edma3ChannelOpen Rx");
//    	return stat;
//    }
//
//
//    /***********************************/
//
//    /* Channel Setup */
//    if (CSL_SOK != CSL_edma3HwChannelSetupParam (hChannelTx[vcpin],
////            0 /* PaRAM entry */ )) {
//			paramNum[vcpin][0])) {
//        printf ("Error in Tx EDMA channel setup\n");
//        return 0;
//    }
//
//
//    /* Channel Setup */
//    if (CSL_SOK != CSL_edma3HwChannelSetupParam (hChannelRx[vcpin],
////            2 /* PaRAM entry */ )) {
//			paramNum[vcpin][2])) {
//        printf ("Error in Rx EDMA channel setup\n");
//        return 0;
//    }
//

    /***********************************/


    //VCPDRV_hParam[vcpin][0] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][0], &stat0);
    //VCPDRV_hParam[vcpin][1] = CSL_edma3GetParamHandle (VCPDRV_hChannelTx[vcpin], VCPDRV_paramNum[vcpin][1], &stat1);
    //VCPDRV_hParam[vcpin][2] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][2], &stat2);
    //VCPDRV_hParam[vcpin][3] = CSL_edma3GetParamHandle (VCPDRV_hChannelRx[vcpin], VCPDRV_paramNum[vcpin][3], &stat3);

    /***********************************/


    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][0], &VCPDRV_paramSetup[vcpin][0]);

    DEBUG(
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 0\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 0\n");
        return 0;
    }
    )

    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][1], &VCPDRV_paramSetup[vcpin][1]);

    DEBUG(
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 1\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 1\n");
        return 0;
    }
    )

    stat = CSL_edma3ParamSetup (VCPDRV_hParam[vcpin][2], &VCPDRV_paramSetup[vcpin][2]);

    DEBUG(
    if (stat == CSL_ESYS_BADHANDLE) {
        ERROR ("Error CSL_ESYS_BADHANDLE in EDMA paRam setup 2\n");
        return 0;
    }
    else if (stat == CSL_ESYS_INVPARAMS) {
        ERROR ("Error CSL_ESYS_INVPARAMS in EDMA paRam setup 2\n");
        return 0;
    }
    )

    
    return CSL_SOK;
}


CSL_Status vcp2_configureEdmaAgain_optimized(
		Uint32 vcpin, 
		VCP2_ConfigIc *pVcpConfig,
		Uint32 *branch_metric, 
		Uint32 *hard_decision,
		Uint32 inputBM, 
		Uint32 outputHD
		) {
	
//	VCP2Handle hVcpThis;
//	hVcpThis = hVcp[vcpin];
	
	ASSERT_PTR_ALIGNED(pVcpConfig, 8);
//	ASSERT_PTR_ALIGNED(outputParams, 8);
//	ASSERT_PTR_ALIGNED(branch_metric, 8);
//	ASSERT_PTR_ALIGNED(hard_decision, 8);	
	
////	printf("vcp config values while setting up edma again\n");
////	printVcpConfig(pVcpConfig);
	
	VCPDRV_paramSetup[vcpin][0].srcAddr = (Uint32) pVcpConfig;
				
				
				
////////    paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
                                                /* Source address increment */

//    VCPDRV_paramSetup[vcpin][1].dstAddr = (Uint32) & (hVcpThis->regs->VCPWBM);
                                                     /* Destination address */
//    VCPDRV_paramSetup[vcpin][1].aCntbCnt = CSL_EDMA3_CNT_MAKE (DMA_BURST_SIZE, inputBM);
    
    
    
    
//    VCPDRV_paramSetup[vcpin][2].aCntbCnt = CSL_EDMA3_CNT_MAKE (outputHD, 1);
                                           /* outputHD bytes in a transfer */
////////    paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
//    paramSetup[vcpin][2].srcDstBidx = CSL_EDMA3_BIDX_MAKE (0, outputHD);
    
//    if (CSL_SOK != CSL_edma3ParamSetup (hParam[vcpin][0], &paramSetup[vcpin][0])) {
//        ERROR ("Error in EDMA paRam setup 0\n");
//        return 0;
//    }

//    if (CSL_SOK != CSL_edma3ParamSetup (hParam[vcpin][1], &paramSetup[vcpin][1])) {
//        ERROR ("Error in EDMA paRam setup 1\n");
//        return 0;
//    }
//    if (CSL_SOK != CSL_edma3ParamSetup (hParam[vcpin][2], &paramSetup[vcpin][2])) {
//        ERROR ("Error in EDMA paRam setup 2\n");
//        return 0;
//    }
    
//    Uint32        *paramHndl = (Uint32*)hParamHndl;
    
    
    *VCPDRV_pBmAddrWord[vcpin] = (Uint32) branch_metric;
    *VCPDRV_pHdAddrWord[vcpin] = (Uint32) hard_decision;

    *VCPDRV_pBmABCntWord[vcpin] = CSL_EDMA3_CNT_MAKE (VCPDRV_DMA_BURST_SIZE, inputBM);
    *VCPDRV_pHdABCntWord[vcpin] = CSL_EDMA3_CNT_MAKE (outputHD, 1);
    *VCPDRV_pHdSrcBIdxWord[vcpin] = CSL_EDMA3_BIDX_MAKE (0, outputHD);
	
////////////////	volatile Uint32 *param0, *param1, *param2, *hParam0, *hParam1, *hParam2;
////////////////	Uint32 i;
////////////////	
//////////////////	paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;
//////////////////	paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;
////////////////	
//////////////////////////////	param0 = (Uint32 *)(&(paramSetup[vcpin][0]));
//////////////////////////////	param1 = (Uint32 *)(&(paramSetup[vcpin][1]));
//////////////////////////////	param2 = (Uint32 *)(&(paramSetup[vcpin][2]));
//////////////////////////////	
//////////////////////////////	hParam0 = (Uint32 *)hParam[vcpin][0];
////////////////	hParam1 = (Uint32 *)hParam[vcpin][1];
////////////////	hParam2 = (Uint32 *)hParam[vcpin][2];
////////////////
//////////////////	    paramSetup[vcpin][1].srcAddr = (Uint32) branch_metric;        /* Source address */
//////////////////	    paramSetup[vcpin][2].dstAddr = (Uint32) hard_decision;          /* Destination */
////////////////	
//////////////////////////////	param1[1] = (Uint32) branch_metric;
//////////////////////////////	param2[3] = (Uint32) hard_decision;
////////////////
//////////////////	hParam1[1] = (Uint32) branch_metric;
//////////////////	hParam2[3] = (Uint32) hard_decision;
////////////////
////////////////	_amem4((void *)&hParam1[1]) = (Uint32) branch_metric;
////////////////	_amem4((void *)&hParam2[3]) = (Uint32) hard_decision;


//ASSERT_PTR_ALIGNED(hParam0, 8);
//ASSERT_PTR_ALIGNED(hParam1, 8);
//ASSERT_PTR_ALIGNED(hParam2, 8);
//ASSERT_PTR_ALIGNED(param0, 8);
//ASSERT_PTR_ALIGNED(param1, 8);
//ASSERT_PTR_ALIGNED(param2, 8);

////////////////#pragma MUST_ITERATE(4,4,4)
////////////////	for (i = 0; i < 4; i+=2) {
////////////////		_amem8(&hParam0[i]) = _amem8(&param0[i]);	
////////////////		_amem8(&hParam1[i]) = _amem8(&param1[i]);
////////////////		_amem8(&hParam2[i]) = _amem8(&param2[i]);
////////////////	}

//#pragma MUST_ITERATE(8,8,8)
//	for (i = 0; i < 8; i++) {
////		_amem4(&hParam0[i]) = _amem4(&param0[i]);	
////		_amem4(&hParam1[i]) = _amem4(&param1[i]);
////		_amem4(&hParam2[i]) = _amem4(&param2[i]);
//		hParam0[i] = param0[i];	
//		hParam1[i] = param1[i];
//		hParam2[i] = param2[i];
//	}
    
    return CSL_SOK;
}


void vcp2_closeEdma() {
	int vcpin = 0;
	for (vcpin = 0; vcpin < 4; vcpin++) {
		CSL_edma3ChannelClose (VCPDRV_hChannelTx[vcpin]);
	    CSL_edma3ChannelClose (VCPDRV_hChannelRx[vcpin]);
	}
}

void vcp2_setupTransferCompletionInterruptMasks() {
	DEBUG(printf("setting up tc interrupt masks\n");)
	
	//set the interrupt region
	VCPDRV_transferCompletionInterruptMask[0].region 		= CSL_EDMA3_REGION_GLOBAL;
	VCPDRV_transferCompletionInterruptMask[1].region 		= CSL_EDMA3_REGION_GLOBAL;
	VCPDRV_transferCompletionInterruptMask[2].region 		= CSL_EDMA3_REGION_GLOBAL;
	VCPDRV_transferCompletionInterruptMask[3].region 		= CSL_EDMA3_REGION_GLOBAL;
	
	//set the interrupt mask
	VCPDRV_transferCompletionInterruptMask[0].intr		= 0x0;
	VCPDRV_transferCompletionInterruptMask[0].intrh	= 0x10000000;	//enable interrupt number 60
	VCPDRV_transferCompletionInterruptMask[1].intr		= 0x0;
	VCPDRV_transferCompletionInterruptMask[1].intrh	= 0x20000000;	//enable interrupt number 61
	VCPDRV_transferCompletionInterruptMask[2].intr		= 0x0;
	VCPDRV_transferCompletionInterruptMask[2].intrh	= 0x40000000;	//enable interrupt number 62
	VCPDRV_transferCompletionInterruptMask[3].intr		= 0x0;
	VCPDRV_transferCompletionInterruptMask[3].intrh	= 0x80000000;	//enable interrupt number 63

}

void vcp2_enableTransferCompletionInterrupts() {
	Uint32 i = 0;
	DEBUG(printf("enabling tc interrupts\n");)
	
	for (i = 0; i < 4; i++)
	CSL_edma3HwControl (VCPDRV_hModule, CSL_EDMA3_CMD_INTR_ENABLE, &VCPDRV_transferCompletionInterruptMask[i]);
}


void vcp2_queryTransferCompletionInterrupt(volatile Uint32 *stat, Uint32 vcpin) {
////	DEBUG(printf("querying tc interrupt register\n");)
	
	CSL_edma3GetHwStatus(VCPDRV_hModule, CSL_EDMA3_QUERY_INTRPEND, 
		&VCPDRV_transferCompletionInterruptMask[vcpin]);
////	DEBUG(printf("interrupt pending status: intrh: 0x%08X  intr: 0x%08X\n", 
////		transferCompletionInterruptMask[vcpin].intrh, transferCompletionInterruptMask[vcpin].intr);)
	
	if (stat != NULL) {
//		*stat = transferCompletionInterruptMask[vcpin].intrh & 0x80000000;
		*stat = VCPDRV_transferCompletionInterruptMask[vcpin].intrh & VCPDRV_intMask[vcpin];
	}

}

void vcp2_clearTransferCompletionInterrupt(Uint32 vcpin) {
////	DEBUG(printf("clearing tc interrupt register for vcpin %d\n", vcpin);)
	CSL_edma3HwControl (VCPDRV_hModule, CSL_EDMA3_CMD_INTRPEND_CLEAR, 
		&VCPDRV_transferCompletionInterruptMask[vcpin]);
}

